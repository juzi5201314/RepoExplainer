这个文件是一个简单的 TCP 回显服务器和客户端的实现，用于使用 Valgrind 检查内存泄漏。

**主要组成部分：**

1.  **依赖项:**
    *   `std::thread::sleep` 和 `std::time::Duration`: 用于在服务器启动后等待一段时间，确保服务器已绑定到端口。
    *   `tokio` crate: 用于异步 I/O 操作，包括网络编程。
    *   `tokio::io::{AsyncReadExt, AsyncWriteExt}`: 用于异步读写操作。
    *   `tokio::net::{TcpListener, TcpSocket}`: 用于创建 TCP 监听器和套接字。
    *   `tokio::runtime::Builder`: 用于构建 Tokio 运行时。
    *   `tokio::sync::oneshot`: 用于在线程之间传递信号。

2.  **常量:**
    *   `TCP_ENDPOINT`: 定义了服务器监听的 IP 地址和端口。
    *   `NUM_MSGS`: 定义了客户端发送和接收的消息数量。
    *   `MSG_SIZE`: 定义了每个消息的大小（以字节为单位）。

3.  **`main` 函数:**
    *   创建了两个 Tokio 运行时 (`rt` 和 `rt2`)，都启用了 I/O。
    *   `rt` 运行时启动了一个异步任务，该任务充当 TCP 回显服务器。
        *   它绑定到 `TCP_ENDPOINT`。
        *   接受客户端连接。
        *   使用 `socket.split()` 将套接字拆分为读写部分。
        *   使用 `tokio::io::copy` 将客户端发送的数据复制回客户端，实现回显功能。
    *   `sleep(Duration::from_millis(100))`: 暂停 100 毫秒，确保服务器已启动并绑定到端口。
    *   创建了一个 `oneshot` 通道 (`tx`, `rx`)，用于在客户端完成消息发送和接收后通知主线程。
    *   `rt2` 运行时启动了一个异步任务，该任务充当 TCP 客户端。
        *   它连接到 `TCP_ENDPOINT`。
        *   循环 `NUM_MSGS` 次，每次：
            *   生成随机字节作为消息内容。
            *   将消息写入服务器。
            *   从服务器读取回显的消息。
        *   发送一个信号到 `oneshot` 通道，通知主线程客户端已完成。
    *   主线程进入一个循环，等待 `oneshot` 通道接收到信号。
        *   `rx.try_recv()` 尝试接收信号。
        *   如果接收到信号，则退出循环。
        *   如果通道关闭，则 panic。
        *   如果通道为空，则继续循环。

**工作流程：**

1.  服务器在后台启动，监听指定端口。
2.  客户端连接到服务器。
3.  客户端发送多条消息到服务器。
4.  服务器将收到的消息回显给客户端。
5.  客户端接收回显的消息。
6.  客户端发送信号通知主线程已完成。
7.  主线程等待信号，然后结束。

**与项目的关系：**
