这个文件定义了用于支持 Tokio 运行时工作窃取调度器的运行队列结构。它包含 `Local` 和 `Steal` 两种句柄，分别用于生产者（单个线程）和消费者（多个线程）。`Inner` 结构体是核心，包含并发更新的头部（head）、仅由生产者更新的尾部（tail）以及存储任务的缓冲区。

**关键组件：**

*   **`UnsignedShort`、`UnsignedLong`、`AtomicUnsignedShort`、`AtomicUnsignedLong`**:  根据是否支持 `atomic_u64` 特性，使用不同的无符号整数类型和原子类型，以提高 ABA 问题的抵抗力。
*   **`Local<T>`**: 生产者句柄，仅供单个线程使用。
*   **`Steal<T>`**: 消费者句柄，可以被多个线程使用，用于从其他队列窃取任务。
*   **`Inner<T>`**: 包含运行队列的核心数据结构。
    *   `head`:  原子无符号长整型，由多个线程并发更新。包含两个 `UnsignedShort` 值：低位字节表示队列的“真实”头部，高位字节由窃取者设置，表示正在窃取的第一个值。用于防止环绕场景。
    *   `tail`:  原子无符号短整型，仅由生产者线程更新。
    *   `buffer`:  一个固定大小的数组，用于存储 `task::Notified<T>` 类型的任务。使用 `UnsafeCell` 包装，因为生产者和窃取者可能同时访问。
*   **`LOCAL_QUEUE_CAPACITY`**:  本地队列的容量，在非 loom 环境下为 256，在 loom 环境下为 4，用于测试。
*   **`MASK`**:  用于计算缓冲区索引的掩码。
*   **`make_fixed_size`**:  用于创建固定大小数组的辅助函数。
*   **`local<T>()`**:  创建一个新的本地运行队列，返回 `Steal` 和 `Local` 句柄。
*   **`Local<T>` 的方法**:
    *   `len()`: 返回队列中的条目数。
    *   `remaining_slots()`: 返回队列中剩余的槽位数量。
    *   `max_capacity()`: 返回队列的最大容量。
    *   `has_tasks()`: 如果队列中有任务，则返回 `true`。
    *   `push_back()`: 将一批任务推送到队列的末尾。
    *   `push_back_or_overflow()`: 将任务推送到队列的末尾，如果队列已满，则触发溢出操作。
    *   `push_back_finish()`: `push_back_or_overflow` 的第二部分，完成任务的推送。
    *   `push_overflow()`: 将一部分任务移动到注入队列。
    *   `pop()`: 从队列中弹出一个任务。
*   **`Steal<T>` 的方法**:
    *   `is_empty()`: 检查队列是否为空。
    *   `steal_into()`: 从当前队列窃取一半的任务，并将它们放入目标队列。
    *   `steal_into2()`:  `steal_into` 的辅助函数，执行实际的任务窃取操作。
*   **`Inner<T>` 的方法**:
    *   `remaining_slots()`: 计算剩余的槽位数量。
    *   `len()`: 计算队列中的任务数量。
    *   `is_empty()`: 检查队列是否为空。
*   **`unpack(n)`**: 将 `head` 值拆分为真实头部和窃取者正在处理的索引。
*   **`pack(steal, real)`**:  将两个头部值组合成一个。

**工作原理：**

该文件实现了一个基于工作窃取的调度器中的本地运行队列。`Local` 句柄用于将任务添加到队列中，`Steal` 句柄用于从其他队列中窃取任务。当一个线程的本地队列为空时，它会尝试从其他线程的队列中窃取任务。为了避免竞争条件，使用了原子操作来同步对 `head` 和 `tail` 的访问。当本地队列已满时，`push_back_or_overflow` 方法会将队列中的一部分任务移动到注入队列中，从而为新任务腾出空间。

**与其他组件的关联：**

该文件是 Tokio 运行时调度器的一部分，与 `task` 模块、`Overflow` trait 和 `Stats` 结构体等其他组件协同工作，以实现任务的调度和执行。
