这个文件定义了 `Parker` 和 `Unparker` 结构体，它们用于管理 Tokio 运行时中的线程暂停和唤醒机制。 它们协同工作，允许运行时线程在没有任务需要处理时进入休眠状态，从而节省 CPU 资源。

**主要组件：**

*   **`Parker`**:  负责暂停线程。它包含一个 `Inner` 结构体的 `Arc` 智能指针，用于共享状态。
    *   `new()`: 创建一个新的 `Parker` 实例，并初始化内部状态，包括一个 `Driver` 实例。
    *   `unpark()`:  返回一个 `Unparker` 实例，用于唤醒线程。
    *   `park()`:  暂停当前线程，直到被唤醒或驱动程序事件发生。
    *   `park_timeout()`: 暂停当前线程，直到超时或被唤醒。  目前仅支持零时长超时，主要用于 Loom 测试。
    *   `shutdown()`:  关闭驱动程序并唤醒所有等待的线程。
*   **`Unparker`**: 负责唤醒线程。它也包含一个 `Inner` 结构体的 `Arc` 智能指针。
    *   `unpark()`: 唤醒与此 `Unparker` 关联的线程。
*   **`Inner`**:  包含 `Parker` 和 `Unparker` 共享的状态。
    *   `state`:  一个 `AtomicUsize`，用于表示线程的当前状态（空闲、等待条件变量、等待驱动程序、已通知）。
    *   `mutex`:  一个 `Mutex`，用于保护对驱动程序和条件变量的访问。
    *   `condvar`:  一个 `Condvar`，用于在驱动程序不可用时阻塞线程。
    *   `shared`:  一个 `Arc<Shared>`，包含共享的驱动程序。
*   **`Shared`**:  包含共享的驱动程序。
    *   `driver`:  一个 `TryLock<Driver>`，用于访问驱动程序。
*   **常量**:
    *   `EMPTY`:  线程空闲状态。
    *   `PARKED_CONDVAR`:  线程正在等待条件变量。
    *   `PARKED_DRIVER`:  线程正在等待驱动程序。
    *   `NOTIFIED`:  线程已被通知。

**工作原理：**

1.  **暂停 (park)**:  当线程没有任务需要处理时，它会调用 `park()`。
2.  **状态检查**:  `park()` 首先检查线程是否已被通知。如果是，则立即返回。
3.  **尝试获取驱动程序**:  `park()` 尝试获取驱动程序的锁。
    *   **成功**:  如果成功获取锁，则调用驱动程序的 `park()` 方法来暂停线程，并将状态设置为 `PARKED_DRIVER`。
    *   **失败**:  如果无法获取锁（驱动程序正在被其他线程使用），则使用条件变量来暂停线程，并将状态设置为 `PARKED_CONDVAR`。
4.  **唤醒 (unpark)**:  当有新的任务或驱动程序事件发生时，`unpark()` 被调用。
5.  **状态更新**:  `unpark()` 将线程状态设置为 `NOTIFIED`，并根据线程当前状态采取不同的唤醒策略。
    *   如果线程正在等待条件变量，则通过 `condvar.notify_one()` 唤醒它。
    *   如果线程正在等待驱动程序，则调用驱动程序的 `unpark()` 方法。
6.  **超时**: `park_timeout()` 允许线程在指定的时间后自动唤醒。

**与项目的关系：**

这个文件是 Tokio 运行时调度器的一部分，负责管理线程的休眠和唤醒，从而优化资源利用率。它与驱动程序（例如，I/O 驱动程序）协同工作，以确保线程在等待 I/O 操作完成时不会浪费 CPU 周期。
