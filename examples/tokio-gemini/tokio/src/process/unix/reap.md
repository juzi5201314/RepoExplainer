这个文件 `reap.rs` 实现了 `Reaper` 结构体，它负责协调子进程退出信号的接收和进程完成的轮询。它主要用于在 Unix 系统上管理子进程的生命周期，确保子进程在退出后被正确地清理，即使父进程意外终止。

**关键组件：**

*   **`Reaper<W, Q, S>` 结构体:**
    *   `inner`: 包含一个实现了 `Wait` trait 的对象，用于等待子进程的退出状态。
    *   `orphan_queue`: 包含一个实现了 `OrphanQueue` trait 的对象，用于处理孤儿进程。
    *   `signal`: 包含一个实现了 `InternalStream` trait 的对象，用于接收子进程退出信号。
*   **`Wait` trait:** 定义了等待子进程完成的方法，例如 `try_wait()`，用于尝试获取子进程的退出状态。
*   **`OrphanQueue` trait:** 定义了处理孤儿进程的方法，例如 `push_orphan()`，用于将孤儿进程添加到队列中。
*   **`InternalStream` trait:** 定义了接收信号的方法，例如 `poll_recv()`，用于轮询接收子进程退出信号。
*   **`Future` trait 的实现:**  `Reaper` 实现了 `Future` trait，使其可以被 `tokio` 运行时轮询。在 `poll` 方法中，它首先尝试获取子进程的退出状态。如果子进程尚未退出，则注册对 `SIGCHLD` 信号的兴趣，以便在子进程退出时得到通知。
*   **`Kill` trait 的实现:** 允许通过 `kill()` 方法向子进程发送信号，例如终止子进程。
*   **`Drop` trait 的实现:**  在 `Reaper` 结构体被丢弃时，它会检查子进程是否已经退出。如果子进程尚未退出，则将其标记为孤儿进程，并将其添加到孤儿进程队列中，以便后续处理。
*   **测试模块:** 包含一系列单元测试，用于验证 `Reaper` 的功能，例如等待子进程退出、处理信号、杀死子进程和处理孤儿进程。

**工作流程：**

1.  `Reaper` 被创建，并持有对子进程的引用、孤儿进程队列和信号流。
2.  `Reaper` 的 `poll` 方法被调用。
3.  `poll` 方法首先尝试获取子进程的退出状态。
4.  如果子进程尚未退出，则注册对 `SIGCHLD` 信号的兴趣。
5.  当收到 `SIGCHLD` 信号时，`poll` 方法再次被调用，并尝试获取子进程的退出状态。
6.  如果子进程已经退出，则返回其退出状态。
7.  如果 `Reaper` 被丢弃，并且子进程尚未退出，则将其标记为孤儿进程，并将其添加到孤儿进程队列中。

**与其他组件的交互：**

*   `Reaper` 与 `tokio` 运行时交互，通过实现 `Future` trait，使其可以被轮询。
*   `Reaper` 使用 `OrphanQueue` 来处理孤儿进程，确保即使父进程意外终止，子进程也能被正确清理。
*   `Reaper` 使用 `InternalStream` 来接收子进程退出信号，以便在子进程退出时得到通知。
*   `Reaper` 使用 `Kill` trait 来允许杀死子进程。
