这个文件定义了一个名为 `Wheel` 的结构体，它实现了定时轮算法。定时轮是一种高效的定时器实现，用于管理大量的定时任务。

**关键组件：**

*   **`Wheel<T>` 结构体:** 这是定时轮的核心。
    *   `elapsed`:  一个 `u64` 类型的变量，表示自定时轮创建以来经过的毫秒数。
    *   `levels`:  一个 `Box<[Level<T>]>` 类型的数组，代表定时轮的层级。定时轮使用多层结构来提高效率。每一层都有 64 个槽位，每个槽位代表一定的时间范围。
*   **`NUM_LEVELS` 常量:**  定义了定时轮的层数，这里设置为 6。
*   **`MAX_DURATION` 常量:**  定义了定时轮可以处理的最大延迟时间。
*   **`InsertError` 枚举:**  定义了插入定时任务时可能发生的错误，包括 `Elapsed` (时间已过) 和 `Invalid` (无效的时间)。
*   **`level` 模块:** 包含了 `Expiration` 结构体，用于表示定时任务的到期时间。
*   **`stack` 模块:** 包含了 `Stack` trait，用于定义定时任务的存储方式（堆或 slab）。
*   **`new()` 方法:**  创建一个新的定时轮。
*   **`elapsed()` 方法:**  返回自定时轮创建以来经过的毫秒数。
*   **`insert()` 方法:**  将一个定时任务插入到定时轮中。
    *   `when`:  定时任务触发的时间（毫秒）。
    *   `item`:  要插入的定时任务。
    *   `store`:  用于存储定时任务的存储结构（例如 slab）。
    *   如果 `when` 小于或等于 `elapsed`，则返回 `Err(Elapsed)`。
    *   如果 `when - elapsed` 大于 `MAX_DURATION`，则返回 `Err(Invalid)`。
    *   根据 `when` 计算出任务应该插入的层级，然后将任务添加到该层级的槽位中。
*   **`remove()` 方法:**  从定时轮中移除一个定时任务。
*   **`poll_at()` 方法:**  返回下一个到期任务的时间（如果存在）。
*   **`peek()` 方法:**  返回下一个到期的任务（但不移除它）。
*   **`poll()` 方法:**  推进定时轮的时间，并处理到期的任务。
    *   `now`:  当前时间。
    *   `store`:  用于存储定时任务的存储结构。
    *   循环检查是否有任务到期，如果到期则返回该任务。
    *   如果当前时间已经超过了所有任务的到期时间，则将定时轮的时间推进到当前时间。
*   **`next_expiration()` 方法:**  返回下一个到期的任务的 `Expiration` 结构体。
*   **`no_expirations_before()` 方法:**  用于调试断言，检查在指定层级之前没有其他任务到期。
*   **`poll_expiration()` 方法:**  处理一个到期的任务。
    *   如果任务在最底层，则返回该任务。
    *   否则，将任务移动到下一层。
*   **`set_elapsed()` 方法:**  设置定时轮的已逝时间。
*   **`pop_entry()` 方法:**  从指定槽位中弹出一个任务。
*   **`peek_entry()` 方法:**  从指定槽位中查看一个任务（但不移除它）。
*   **`level_for()` 方法:**  根据任务的触发时间计算出应该插入的层级。
*   **`level_for()` 函数:**  计算任务应该插入的层级。
*   **`test` 模块:** 包含单元测试，用于验证 `level_for` 函数的正确性。

**工作原理：**

定时轮通过多层结构来管理定时任务。每一层都有 64 个槽位，每个槽位代表一定的时间范围。当插入一个定时任务时，根据任务的触发时间计算出它应该插入的层级和槽位。当定时轮的时间推进时，它会检查当前时间是否超过了某个槽位的时间范围。如果超过了，则将该槽位中的任务移动到下一层，或者在最底层直接触发任务。

**与其他组件的关系：**

*   `level` 模块定义了定时轮的层级结构。
*   `stack` 模块定义了定时任务的存储方式。
*   `Timer` 和 `DelayQueue` 使用 `Wheel` 作为其底层实现。
