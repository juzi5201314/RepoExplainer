### 文件目的
`notify.rs` 是 Tokio 异步运行时中用于实现轻量级任务通知机制的核心模块。它提供了 `Notify` 结构体，允许单个任务通过异步等待通知来协调执行流程，类似于 `thread::park` 和 `unpark` 的功能，但专为异步编程设计。

### 核心组件与功能
#### 1. **Notify 结构体**
- **功能**：维护一个通知状态和等待任务列表，支持单次通知（`notify_one`）和批量通知（`notify_waiters`）。
- **关键字段**：
  - `state`: 使用原子整数维护状态（空、等待、已通知）和通知计数。
  - `waiters`: 通过 `Mutex` 保护的等待任务链表，存储 `Waiter` 结构体实例。

#### 2. **Waiter 结构体**
- **功能**：表示等待通知的任务，包含唤醒器（`Waker`）和通知状态。
- **关键特性**：
  - 通过原子操作管理通知状态（`AtomicNotification`）。
  - 使用 intrusive linked list 实现高效链表操作，避免额外内存分配。

#### 3. **Notified Future**
- **功能**：通过 `Notify::notified()` 返回的异步 future，用于等待通知。
- **状态机**：
  - `Init`: 初始状态，尚未开始等待。
  - `Waiting`: 已加入等待队列。
  - `Done`: 已收到通知或完成等待。
- **方法**：
  - `enable()`: 手动将 future 加入等待队列（避免遗漏通知）。
  - `poll()`: 检查通知状态并处理唤醒。

#### 4. **通知策略**
- **notify_one()**: 通知队列中的第一个任务（FIFO）或最后一个任务（LIFO）。
- **notify_waiters()**: 唤醒所有等待任务，适用于需要同时通知所有等待者的场景。

### 关键技术细节
- **原子状态管理**：通过 `AtomicUsize` 精确控制状态转换（如 `EMPTY`、`WAITING`、`NOTIFIED`）。
- **链表与锁**：`Mutex` 保护 `waiters` 链表，确保线程安全的插入/移除操作。
- **唤醒机制**：使用 `Waker` 和 intrusive linked list 实现高效任务唤醒，避免竞态条件。

### 使用场景示例
1. **基础用法**：单任务通知，如示例中通过 `notify_one()` 唤醒等待的异步任务。
2. **无界通道**：
   - **单生产者多消费者（MPSC）**：利用 `notify_one()` 确保至少一个消费者被唤醒。
   - **多生产者多消费者（MPMC）**：通过 `enable()` 避免通知丢失，确保所有等待者被处理。

### 在项目中的角色