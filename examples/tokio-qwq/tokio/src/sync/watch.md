### 文件目的
该文件实现了 Tokio 的 `watch` 通道，这是一种多生产者多消费者通道，仅保留最新发送的值。它适用于需要在代码中多个位置观察值变化的场景（如配置变更），通过生产者和消费者之间的异步通知机制实现高效协同。

---

### 核心组件
#### 1. **核心结构**
- **`Sender<T>`**：生产者端，负责发送新值。支持克隆，内部通过 `Arc<Shared<T>>` 共享状态。
- **`Receiver<T>`**：消费者端，跟踪已读取的版本。支持克隆，每个实例独立维护已读版本号。
- **`Shared<T>`**：共享状态容器，包含：
  - `value`: 当前值（`RwLock<T>` 保护）
  - `state`: 版本号和通道关闭状态（原子操作管理）
  - `ref_count_rx/tx`: 接收端/发送端引用计数
  - `notify_rx/tx`: 接收端变更通知和发送端关闭通知机制

#### 2. **关键方法**
- **`channel<T>(init: T)`**：创建通道，返回 `(Sender, Receiver)`。初始值通过 `RwLock` 保护。
- **`Sender::send`**：发送新值，若无活跃接收端返回错误。通过原子操作更新版本号并通知等待者。
- **`Receiver::borrow`**：获取当前值（不标记为已读），可能因锁竞争导致阻塞。
- **`Receiver::borrow_and_update`**：获取当前值并标记为已读，避免竞态条件。
- **`Receiver::changed()`**：异步等待新值，通过 `Notify` 实现高效唤醒。
- **`Sender::subscribe()`**：创建新接收端，即使原有接收端已关闭也能重新激活通道。

#### 3. **状态管理**
- **版本机制**：通过 `AtomicState` 管理版本号，每次更新递增 `STEP_SIZE`（步长为 2 避免与关闭标记冲突）。
- **关闭标记**：最低位标记通道是否关闭（所有接收端已释放）。
- **通知优化**：`BigNotify` 使用多个 `Notify` 实例分摊唤醒压力，减少锁竞争。

#### 4. **错误处理**
- **`SendError`**：发送失败（通道关闭或无接收端）。
- **`RecvError`**：接收通知失败（生产者已关闭）。

---

### 工作原理
1. **发送流程**：
   - 生产者调用 `send` 时，若存在活跃接收端，更新 `value` 并递增版本号。
   - 通过 `notify_rx` 唤醒所有等待的接收端。
   
2. **接收流程**：
   - 接收端调用 `borrow` 获取当前值，但未标记为已读。
   - 调用 `borrow_and_update` 或 `changed()` 标记版本为已读。
   - `changed()` 异步等待时，通过 `notify_rx` 唤醒，确保只在新值到达时触发。

3. **关闭机制**：
   - 当所有接收端释放时，`Sender` 的 `is_closed()` 返回 `true`。
   - `closed()` 异步等待通道关闭事件，供生产者感知兴趣消失。

---

### 项目中的角色