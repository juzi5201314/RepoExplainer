# 文件说明：`stdio_common.rs`

## 文件目的
该文件实现了 `SplitByUtf8BoundaryIfWindows` 结构体，用于在 Windows 平台上处理标准输出（stdout）和标准错误（stderr）的 UTF-8 编码问题。其核心功能是确保写入的字节流始终以完整的 UTF-8 字符边界结束，避免因不完整字符导致的乱码或错误。

---

## 关键组件

### 1. `SplitByUtf8BoundaryIfWindows<W>` 结构体
- **功能**：包装一个异步写入器（`AsyncWrite`），在 Windows 平台上对缓冲区进行 UTF-8 边界检查和截断。
- **实现细节**：
  - **平台差异处理**：
    - **Windows**：检查缓冲区是否为有效 UTF-8，若存在不完整字符则截断到最近的完整字符边界。
    - **其他平台**：直接传递数据，不做修改。
  - **常量定义**：
    - `MAX_BYTES_PER_CHAR`：UTF-8 最大字节数（4，遵循 Unicode 标准）。
    - `MAGIC_CONST`：用于确定检查初始字节范围的系数（默认值为 8，可调整）。
  - **截断逻辑**：
    1. **初步截断**：将缓冲区长度限制为 `DEFAULT_MAX_BUF_SIZE`（来自 `tokio::io::blocking`）。
    2. **UTF-8 检查**：检查前 `MAX_BYTES_PER_CHAR * MAGIC_CONST` 字节是否为有效 UTF-8。
    3. **边界查找**：若需修正，则从缓冲区末尾反向查找不完整字符的起始位置，并截断。

### 2. `poll_write` 方法
- **核心逻辑**：
  - **条件判断**：仅在 Windows 或测试环境下执行 UTF-8 处理。
  - **性能优化**：对小缓冲区（≤ `DEFAULT_MAX_BUF_SIZE`）直接写入，避免额外检查。
  - **截断实现**：
    - 使用 UTF-8 编码规则（后续字节以 `0b10` 开头）反向查找不完整字符的边界。
    - 截断后确保写入的数据始终为完整 UTF-8 字符。

### 3. 测试模块
- **测试用例**：
  - **`test_splitter`**：验证 UTF-8 缓冲区正确截断。
  - **`test_pseudo_text`**：测试二进制数据前缀为文本时的截断边界条件。
- **模拟写入器**：
  - `TextMockWriter`：验证缓冲区长度和 UTF-8 合法性。
  - `LoggingMockWriter`：记录写入历史，验证截断逻辑的正确性。

---

## 在项目中的角色
该文件是 Tokio 异步 I/O 框架中处理标准输入输出的核心组件之一，专门解决 Windows 平台因不完整 UTF-8 字符导致的写入问题，确保标准输出和错误流的文本完整性，同时兼顾性能优化。它通过适配器模式包装底层写入器，为上层提供跨平台一致的 UTF-8 安全保证。
