# 文件解释：`tokio/src/macros/try_join.rs`

## **目的**  
该文件定义了 Tokio 的 `try_join!` 宏，用于在异步环境中并发执行多个 `Future`，并在所有分支成功完成时返回结果，或在第一个分支失败时立即短路返回错误。它是 Tokio 异步编程模型中处理多任务并发的核心工具之一。

---

## **关键组件**

### **1. 文档生成宏 (`doc!`)**  
- **功能**：通过 `macro_rules! doc` 宏自动生成 `try_join!` 的文档说明。
- **内容**：
  - **功能描述**：说明 `try_join!` 的核心行为（并发执行、短路错误）及使用限制（需在 `async` 环境中使用）。
  - **与 `join!` 的对比**：强调 `try_join!` 处理 `Result` 类型，而 `join!` 直接收集所有结果。
  - **注意事项**：
    - **非并行性**：所有分支在同一个任务中运行，无法跨线程并行。若需并行，需通过 `tokio::spawn` 创建任务。
    - **内存优化**：直接内联存储 `Future`，无需 `Vec` 分配。
  - **示例**：
    - 基础用法：两个异步函数的 `try_join!`。
    - 结合 `tokio::spawn` 实现并行任务的示例。

### **2. 宏实现 (`try_join!`)**  
- **结构**：
  - **入口**：`try_join!(expr1, expr2, ...)` 调用展开为内部宏 `@` 规则。
  - **参数规范化**：
    - 统计分支数量（`$total`）。
    - 将所有 `Future` 存储为元组 `futures`。
  - **轮询逻辑**：
    - 使用 `poll_fn` 创建一个 `Future`，在每次轮询时按顺序检查各分支状态。
    - **错误处理**：若某分支返回 `Err`，立即返回错误。
    - **进度控制**：通过 `skip_next_time` 变量轮换轮询顺序，避免某些分支被长期阻塞。
  - **结果收集**：所有分支成功时，提取 `Ok` 值并返回元组。

### **3. 安全性与优化**  
- **内存安全**：
  - 直接使用 `unsafe { Pin::new_unchecked }` 固定 `Future` 在栈上，确保符合 `Pin` 的语义。
  - 元组存储避免动态分配。
- **性能优化**：
  - 双层循环轮询策略，确保每个分支公平获取轮询机会。

---

## **项目中的角色**  