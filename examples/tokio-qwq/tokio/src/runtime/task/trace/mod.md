# 文件解释：`tokio/src/runtime/task/trace/mod.rs`

## **目的**  
此文件是 Tokio 异步运行时中用于**任务执行追踪与调试**的核心模块。它通过捕获任务的执行路径（backtrace）和构建调用树，为运行时提供任务状态快照能力（如 `Handle::dump`），帮助开发者诊断死锁、任务阻塞等问题。

---

## **关键组件与功能**

### **1. 数据结构**
#### **`Context`**  
- **作用**：维护当前线程的追踪上下文，包含活跃的调用帧（`active_frame`）和收集器（`collector`）。
- **核心字段**：
  - `active_frame`: 当前执行栈的根节点指针，用于限定回溯范围。
  - `collector`: 存储捕获的 `Trace` 对象，用于收集多层调用的 backtrace。
- **方法**：
  - `is_tracing()`: 检查当前任务是否处于追踪状态。
  - `try_with_current`: 安全地访问线程局部的上下文。

#### **`Frame`**  
- **作用**：表示调用栈中的一个帧，通过双向链表结构记录调用层级。
- **字段**：
  - `inner_addr`: 当前帧的函数地址。
  - `parent`: 父级帧的指针，形成链式结构。

#### **`Trace`**  
- **作用**：存储多个线性 backtrace，并支持将其转换为树状结构（通过 `Tree` 模块）。
- **方法**：
  - `capture<F>`: 执行闭包并捕获所有 `trace_leaf` 调用处的 backtrace。
  - `root<F>`: 创建包裹 Future 的 `Root`，作为追踪的起点。
  - `fmt`: 通过 `Tree` 将 backtrace 格式化为可读的调用树。

---

### **2. 核心功能实现**
#### **`trace_leaf` 函数**  
- **触发条件**：在 `Trace::capture` 的子调用中调用，用于捕获当前栈帧。
- **流程**：
  1. 检查是否存在活跃的 `Trace` 收集器。
  2. 使用 `backtrace` crate 捕获当前栈帧，过滤无关帧（如排除内部实现细节）。
  3. 将过滤后的 backtrace 添加到收集器中。
  4. 若成功捕获，通过调度器延迟唤醒任务，使追踪在异步上下文中生效。

#### **`Root` Future**  
- **作用**：包裹用户 Future，作为追踪的根节点。
- **实现细节**：
  - `poll` 方法设置当前帧为根节点，并在退出时恢复上下文。
  - 使用 `defer` 机制确保帧指针的正确恢复，避免内存问题。

#### **任务追踪函数**  
- **`trace_current_thread` 和 `trace_multi_thread`**：
  - **功能**：遍历当前运行时的所有任务，捕获其执行路径。
  - **流程**：
    1. 清空任务队列（本地队列和注入队列）。
    2. 通知所有任务使其可轮询（`notify_for_tracing`）。
    3. 使用 `Trace::capture` 捕获每个任务的执行轨迹，返回 `(任务ID, Trace)` 列表。

---

### **3. 与其他模块的集成**
- **调度器集成**：通过 `scheduler` 模块与 Tokio 的调度器交互，确保任务在追踪时正确唤醒和轮询。
- **符号解析**：依赖 `symbol` 和 `tree` 模块将原始地址转换为符号名称，并构建可读的调用树。
- **运行时接口**：支持 `Handle::dump` 等 API，提供完整的运行时任务快照。

---

## **在项目中的角色**  