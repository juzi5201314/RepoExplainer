### 文件说明

#### 目的
`abort.rs` 文件定义了 Tokio 运行时中的 `AbortHandle` 结构体，用于提供对异步任务的主动终止能力。该结构体允许在不等待任务完成的情况下强制终止任务，同时明确区分了与 `JoinHandle` 的不同职责。

---

#### 关键组件

1. **结构体定义**
   ```rust
   pub struct AbortHandle {
       raw: RawTask,
   }
   ```
   - **`raw`**: 存储任务的底层表示 `RawTask`，用于直接操作任务状态。

2. **核心方法**
   - **`abort()`**:  
     调用 `raw.remote_abort()` 触发任务终止。注意：
     - 对 `spawn_blocking` 创建的阻塞任务无效（因其非异步特性）。
     - 若任务已终止则无操作。
   - **`is_finished()`**:  
     通过检查 `RawTask` 的状态判断任务是否已完成（包括被终止的情况）。
   - **`id()`**:  
     返回任务的唯一标识符 `Id`，用于调试和跟踪。

3. **生命周期管理**
   - **`Drop` 实现**:  
     调用 `raw.drop_abort_handle()` 释放资源或减少引用计数。
   - **`Clone` 实现**:  
     通过 `raw.ref_inc()` 增加引用计数，允许创建多个 `AbortHandle` 实例共同控制同一任务。

4. **安全特性**
   - 标记为 `Send`/`Sync`，支持跨线程安全传递。
   - 实现 `UnwindSafe`/`RefUnwindSafe`，确保在 panic 时的安全性。

5. **调试支持**
   - **`Debug` 实现**:  
     显示任务的 ID，便于调试时识别具体任务。

---

#### 工作原理
- **任务终止机制**:  
  调用 `abort()` 时，通过 `RawTask` 的 `remote_abort()` 方法通知任务线程终止。任务需自行处理终止信号（如检查取消标志）。
- **阻塞任务限制**:  
  `spawn_blocking` 创建的任务无法被终止，因其运行在独立线程且不响应异步信号，仅在任务未启动时可能阻止其执行。
- **引用计数管理**:  
  通过 `Clone` 方法增加引用计数，确保多个 `AbortHandle` 可安全操作同一任务。

---

#### 项目中的角色