### 代码文件解释

#### 目的
该文件是 Tokio 异步运行时中专门处理阻塞操作的线程池核心实现。其主要目的是为耗时的同步阻塞操作（如文件 I/O、长时间计算等）提供独立的线程池，避免阻塞主事件循环，从而保持异步运行时的高效性。

#### 关键组件
1. **BlockingPool 结构体**
   - 管理线程池的生命周期和关闭逻辑。
   - 包含 `Spawner` 用于任务提交，以及 `shutdown_rx` 监听关闭信号。
   - `new` 方法通过 `Builder` 初始化线程池参数（如线程容量、存活超时时间）。

2. **Spawner 结构体**
   - 负责任务的提交和线程池的扩展。
   - 通过 `Arc<Inner>` 共享线程池状态。
   - 提供 `spawn_blocking` 和 `spawn_mandatory_blocking` 方法提交任务，区分非强制和强制执行的任务（强制任务在关闭时仍会尝试执行）。

3. **Inner 结构体**
   - 存储线程池的核心状态：
     - `shared`: 共享的队列、线程集合等（通过 `Mutex` 保护）。
     - `condvar`: 用于线程间的通知与等待。
     - 配置参数（线程名称、堆栈大小、存活超时等）。
     - 统计指标（线程数、空闲线程数、队列深度）。

4. **Task 结构体**
   - 封装实际任务及执行策略：
     - `task`: 待执行的异步任务（基于 `BlockingSchedule` 调度）。
     - `mandatory`: 标记任务是否为强制执行（如文件系统操作需确保执行完成）。

5. **线程管理逻辑**
   - **任务队列**：通过 `VecDeque` 存储待执行任务，任务提交时检查队列状态并触发线程唤醒。
   - **线程创建**：当无空闲线程且未达线程上限时，动态创建新线程（`spawn_thread`）。
   - **线程生命周期**：
     - 线程启动后进入任务处理循环，处理队列任务。
     - 空闲时通过 `Condvar` 等待通知，超时未唤醒则自动退出。
     - 关闭时强制处理剩余任务并清理线程。

6. **错误处理**
   - `SpawnError` 处理任务提交失败场景（如线程池关闭或系统无法创建新线程）。
   - 强制任务在关闭时仍尝试执行，而非强制任务直接丢弃。

#### 工作流程
1. **任务提交**：
   - 调用 `spawn_blocking` 或 `spawn_mandatory_blocking` 将任务加入队列。
   - 若无空闲线程且未达线程上限，触发新线程创建。

2. **线程执行**：
   - 工作线程循环从队列中取出任务执行。
   - 空闲时通过条件变量等待通知，超时未唤醒则退出。

3. **关闭流程**：
   - 调用 `shutdown` 标记关闭状态，唤醒所有线程。
   - 线程处理完剩余任务后退出，主进程等待所有线程终止。

#### 项目中的角色