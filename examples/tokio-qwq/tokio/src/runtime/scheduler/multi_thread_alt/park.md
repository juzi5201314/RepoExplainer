# 文件说明：Tokio 运行时线程调度的停车管理模块

## 文件作用
该文件实现了 Tokio 运行时多线程调度器中的停车（parking）机制，负责管理线程的休眠与唤醒。通过协调资源驱动器（Driver）和条件变量（Condvar），确保线程在无任务时进入休眠状态，并在有新事件时及时唤醒。

## 核心组件

### 1. **Parker 结构体**
- **功能**：线程休眠管理器
- **关键方法**：
  - `park()`: 尝试通过驱动器或条件变量使线程休眠
  - `park_timeout()`: 支持超时休眠（当前仅支持立即休眠）
  - `shutdown()`: 关闭资源并通知所有等待线程
- **实现细节**：
  - 使用 `Arc<Inner>` 实现跨线程共享
  - 通过 `try_lock` 尝试获取驱动器资源，若失败则通过条件变量等待

### 2. **Unparker 结构体**
- **功能**：线程唤醒触发器
- **关键方法**：
  - `unpark()`: 通过修改状态或直接唤醒驱动器来通知休眠线程
- **实现细节**：
  - 与 Parker 共享 `Inner` 状态，确保原子性操作

### 3. **Inner 结构体**
- **核心字段**：
  - `state`: 原子状态标志（EMPTY/PARKED_CONDVAR/PARKED_DRIVER/NOTIFIED）
  - `mutex` 和 `condvar`: 协调线程间同步
  - `shared.driver`: 尝试独占访问的资源驱动器（TryLock 包装）
- **状态转换逻辑**：
  - `park()` 方法根据当前状态选择休眠方式（驱动器或条件变量）
  - `unpark()` 通过原子操作更新状态并触发唤醒

### 4. **Shared 结构体**
- **功能**：资源驱动器的共享管理
- **关键字段**：
  - `driver`: 使用 `TryLock` 实现驱动器的独占访问控制

## 核心逻辑流程

### 线程休眠流程（`park()`）
1. **状态检查**：若已收到唤醒通知（NOTIFIED），直接返回
2. **尝试获取驱动器**：
   - 成功：调用 `park_driver()` 直接通过驱动器休眠
   - 失败：通过 `park_condvar()` 使用条件变量等待
3. **条件变量休眠**：
   - 锁定 `mutex` 并设置状态为 PARKED_CONDVAR
   - 循环等待条件变量通知，直到收到有效唤醒信号

### 线程唤醒流程（`unpark()`）
1. **状态更新**：将 `state` 设置为 NOTIFIED
2. **唤醒方式选择**：
   - 若线程处于 `PARKED_CONDVAR`：通过 `condvar.notify_one()` 唤醒
   - 若处于 `PARKED_DRIVER`：直接调用驱动器的 `unpark()` 方法

## 在项目中的角色
该文件是 Tokio 多线程运行时调度的核心组件，通过高效的线程休眠与唤醒机制，实现资源的按需分配和释放，确保异步任务和 I/O 事件的及时处理，从而提升运行时的整体性能和响应能力。
