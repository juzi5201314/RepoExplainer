# 文件说明：`tokio/src/runtime/signal/mod.rs`

## **功能概述**  
该文件是 Tokio 运行时信号处理模块的核心实现，负责在操作系统信号触发时唤醒事件循环，并将信号通知给注册的监听器。它通过 Unix 套接字管道（`UnixStream`）接收信号事件，并依赖 IO 驱动来监听管道的可读事件。

---

## **关键组件**

### **1. `Driver` 结构体**
- **职责**：管理信号事件的注册、接收和分发。
- **核心字段**：
  - `io`: 内部依赖的 IO 驱动，用于事件循环的阻塞和超时控制。
  - `receiver`: 通过 Unix 套接字管道接收信号唤醒事件的接收端。
  - `inner`: 使用 `Arc<()>` 管理驱动的生命周期，确保安全引用。

#### **关键方法**
- **`new`**  
  初始化信号驱动：
  - 从全局信号注册表（`globals().receiver`）获取接收端文件描述符，并克隆为新的 `UnixStream`。
  - 将管道注册到 IO 驱动的事件循环中，确保信号事件能触发 IO 醒目。
- **`process`**  
  处理信号事件：
  1. 检查 IO 驱动是否收到管道的可读事件。
  2. 完全读取管道内容（避免残留数据影响后续事件）。
  3. 触发全局信号广播（`globals().broadcast()`），通知所有监听器。

### **2. `Handle` 结构体**
- **职责**：提供对 `Driver` 的弱引用句柄，用于跨线程安全访问。
- **核心字段**：
  - `inner`: 使用 `Weak<()>` 检查驱动是否存活。

#### **关键方法**
- **`check_inner`**  
  验证驱动是否存活：若 `Arc` 的强引用计数为 0，则返回错误，防止使用已释放的驱动。

---

## **实现细节**
- **信号管道机制**：  
  通过全局共享的 Unix 套接字管道（`globals().receiver`）接收信号。每个 `Driver` 实例创建独立的接收端副本，避免文件描述符复用问题（参考 `tokio-process#42` 的历史问题）。
- **与 IO 驱动的协作**：  
  信号事件通过管道的可读事件触发 IO 驱动的唤醒，确保信号处理与事件循环无缝集成。
- **错误处理**：  
  在读取管道时，若遇到 `WouldBlock` 则正常退出；其他错误（如 EOF 或未知错误）直接 panic，因信号管道不应提前关闭。

---

## **项目中的角色**
该文件是 Tokio 运行时信号处理的核心实现，负责将操作系统信号转换为异步事件，并通过事件循环分发给监听器，确保 Tokio 的异步任务能响应信号（如终止、中断等）。它依赖 IO 驱动完成事件监听，并与全局信号注册表协作，是 Tokio 异步信号处理的关键组件。
