### 文件解释：`tokio/src/util/try_lock.rs`

#### **文件目的**
该文件实现了 Tokio 内部使用的非阻塞锁 `TryLock`，用于在异步运行时中安全地管理对共享资源的访问。与阻塞锁不同，`try_lock()` 方法会立即返回锁的获取结果（成功或失败），避免线程阻塞，符合异步编程的非阻塞特性。

---

#### **关键组件**

1. **`TryLock<T>` 结构体**
   - **字段**：
     - `locked: AtomicBool`：原子布尔值，标记锁是否被占用（`true` 表示已锁定）。
     - `data: UnsafeCell<T>`：使用 `UnsafeCell` 存储实际数据，允许在编译时常量上下文中修改内部值（突破 Rust 的借用规则）。
   - **特性**：
     - 通过 `unsafe impl Send/Sync` 声明，确保当 `T` 实现 `Send` 时，锁本身可安全跨线程传递，并且当 `T` 同时实现 `Sync` 时支持多线程并发访问。

2. **`LockGuard<'a, T>` 结构体**
   - **字段**：
     - `lock: &'a TryLock<T>`：持有对锁的引用，确保锁在作用域内有效。
     - `_p: PhantomData`：生命周期标记，避免编译器优化错误。
   - **行为**：
     - **`Deref` 和 `DerefMut`**：允许通过 `LockGuard` 直接访问和修改锁保护的数据。
     - **`Drop`**：在离开作用域时自动释放锁，将 `locked` 置为 `false`。

3. **`try_lock()` 方法**
   - 使用原子操作 `compare_exchange` 尝试将 `locked` 从 `false` 改为 `true`：
     - 若成功（锁未被占用），返回 `Some(LockGuard)`。
     - 若失败（锁已被占用），返回 `None`。
   - 使用 `SeqCst` 内存顺序保证跨线程可见性和操作顺序性。

4. **`new()` 构造函数**
   - 根据是否启用 `loom` 测试框架（通过 `cfg` 宏条件编译）：
     - 非 `loom` 环境下使用 `const fn` 实现零成本初始化。
     - `loom` 环境下通过普通函数实现，支持并发模拟测试。

---

#### **实现细节**
- **非阻塞特性**：`try_lock()` 方法立即返回，避免线程阻塞，适合异步任务调度。
- **内存安全**：
  - `UnsafeCell` 允许内部数据被多个线程同时访问，但通过原子操作和锁机制确保同一时间只有一个线程可修改数据。
  - `PhantomData` 防止编译器错误优化 `LockGuard` 的生命周期。
- **跨平台兼容性**：通过 `cfg(loom)` 分支支持测试环境与生产环境的差异。

---

#### **项目中的角色**
此文件为 Tokio 提供了轻量级的非阻塞锁实现，用于在异步任务中安全地共享和修改资源，确保线程安全的同时避免阻塞，是 Tokio 内部并发控制的核心组件之一。
