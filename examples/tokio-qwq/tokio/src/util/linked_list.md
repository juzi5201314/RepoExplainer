### 文件说明：`tokio/src/util/linked_list.rs`

#### **功能与目的**
该文件实现了 Tokio 内部使用的**侵入式双链表数据结构**，用于高效管理需要被“固定”（pinned）的节点。其核心特点包括：
1. **侵入式设计**：节点本身包含链表指针，无需额外分配内存。
2. **支持 pinned 节点**：确保节点在链表中时不会被移动，满足异步任务等场景对内存稳定性的需求。
3. **安全约束**：大部分 API 标记为 `unsafe`，要求使用者保证节点与链表状态的一致性。

#### **关键组件**
1. **`LinkedList<L, T>` 结构体**
   - **字段**：
     - `head`: 链表头节点指针（`Option<NonNull<T>>`）
     - `tail`: 链表尾节点指针（`Option<NonNull<T>>`）
     - `_marker`: 类型标记，确保泛型参数的正确性。
   - **功能**：
     - 提供 `push_front`、`pop_front`、`pop_back` 等操作，通过 `unsafe` 代码直接操作指针。
     - `remove` 方法要求调用者保证节点在链表中，需谨慎使用。

2. **`Link` 特质**
   - **定义**：规定类型如何被链表追踪。
   - **要求**：
     - `Target` 类型必须是 pinned 的（即插入后不移动）。
     - 提供 `as_raw`、`from_raw` 等方法转换指针与句柄。
   - **安全约束**：实现需确保指针操作符合 Rust 的内存模型。

3. **`Pointers<T>` 结构体**
   - **字段**：
     - `prev`: 前驱节点指针（`Option<NonNull<T>>`）
     - `next`: 后继节点指针（`Option<NonNull<T>>`）
     - `_pin`: 通过 `PhantomPinned` 确保类型为 `!Unpin`，避免内存移动。
   - **实现细节**：
     - 使用 `UnsafeCell` 实现内部可变性。
     - 提供 `get_prev`、`get_next` 等安全访问方法，避免直接引用导致的别名问题。

4. **`GuardedLinkedList`**
   - **设计**：通过“哨兵节点”简化边界条件，链表始终为循环结构。
   - **优势**：空链表时哨兵节点自身指向自己，无需特殊处理 `None`。

#### **核心方法**
- **`push_front`**：将节点插入头部，更新前后指针。
- **`pop_front/pop_back`**：移除头/尾节点，调整相邻节点指针。
- **`remove`**：通过 `unsafe` 移除指定节点，需确保节点在链表中。
- **`drain_filter`**：迭代过滤并移除符合条件的节点。
- **`into_guarded`**：将普通链表转换为带哨兵节点的链表。

#### **安全与限制**
- **内存安全**：依赖 `unsafe` 代码直接操作指针，要求使用者保证：
  - 节点在插入后不被移动（pinned）。
  - 移除操作前节点确实存在于链表中。
- **生命周期管理**：链表本身不负责释放节点内存，需调用者确保节点在链表外被正确释放。

#### **项目中的角色**