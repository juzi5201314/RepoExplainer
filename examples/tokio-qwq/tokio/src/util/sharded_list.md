# ShardedList.rs 文件详解

## 文件目的
该文件实现了 `ShardedList` 结构体，这是一个基于分片设计的高并发安全的侵入式链表。通过将数据分散到多个分片（Shard），并为每个分片配备独立的锁，显著降低了多线程操作时的锁竞争，适用于 Tokio 异步运行时中需要高效管理大量元素的场景。

---

## 核心组件与功能

### 1. **`ShardedList<L, T>` 结构体**
- **字段说明**：
  - `lists`: 分片列表，每个分片是一个 `Mutex<LinkedList>`，通过 `shard_mask` 快速定位分片。
  - `added`: 记录添加到链表的元素总数（原子计数器，用于统计）。
  - `count`: 当前链表元素总数（原子计数器，实时更新）。
  - `shard_mask`: 分片掩码（`sharded_size - 1`），用于快速计算分片索引。

- **初始化**：
  - `new(sharded_size: usize)` 方法要求分片数量为 `2` 的幂次，通过 `shard_mask = sharded_size - 1` 实现高效取模运算。

---

### 2. **`ShardedListItem` 安全性 trait**
- **职责**：
  - 要求实现者提供 `get_shard_id` 方法，返回元素所属的分片 ID。
  - **安全保证**：必须确保同一元素的 `shard_id` 在多次调用中保持不变，否则可能导致数据不一致。

---

### 3. **关键方法**
#### a. **`pop_back(shard_id: usize)`**
- 从指定分片的链表尾部弹出元素，原子递减 `count`。

#### b. **`remove(node: NonNull<T>)`**
- **不安全操作**：根据元素的 `shard_id` 定位分片并安全移除节点，需确保节点确实存在于该分片。

#### c. **`lock_shard(val: &Handle)`**
- 根据元素的 `shard_id` 获取分片锁，返回 `ShardGuard` 守护结构体，持有锁和计数器引用。

#### d. **`ShardGuard` 结构体**
- **作用**：持有分片锁并提供安全操作：
  - `push(val)`：将元素推入分片链表头部，更新 `added` 和 `count`。
  - 内部通过 `id` 校验元素所属分片的正确性。

---

### 4. **分片定位机制**
- **`shard_inner(id: usize)`**：
  - 使用 `id & shard_mask` 快速计算分片索引（等效于 `id % sharded_size`），通过 `get_unchecked` 直接访问分片。
  - 安全性依赖 `shard_mask` 的正确性和 `shard_id` 的合法性。

---

### 5. **并发与性能优化**
- **分片设计**：每个分片独立加锁，允许多线程并发操作不同分片，显著降低锁竞争。
- **原子计数器**：`count` 和 `added` 使用原子操作，避免因计数导致的额外锁开销。
- **侵入式链表**：元素自身包含链表节点指针，减少内存分配和数据拷贝。

---

### 6. **调试与统计**
- **`for_each` 方法**（通过 `cfg_taskdump` 宏启用）：
  - 锁定所有分片并遍历元素，用于调试或任务转储（Task Dump）。
- **`added()` 方法**：返回链表总添加元素数（64位系统支持）。

---

## 在项目中的角色
`ShardedList` 是 Tokio 内部的核心数据结构之一，用于高效管理需要高并发访问的元素集合（如任务队列、资源池等）。通过分片和原子操作的结合，它在保证线程安全的同时，最大限度地减少锁竞争，是 Tokio 实现高性能异步运行时的重要基石。
