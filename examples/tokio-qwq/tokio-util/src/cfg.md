# 文件说明：`cfg.rs`

## **文件目的**  
此文件定义了一系列宏，用于简化 Tokio 库中基于功能特性的条件编译（`cfg`）和文档标记（`doc`）。通过这些宏，代码可以根据用户启用的特征（feature）动态包含或排除特定模块，同时确保文档正确标注功能依赖关系。

---

## **关键组件与功能**

### **1. 宏定义**
文件中定义了多个以 `cfg_` 开头的宏，每个宏对应一个或多个功能特征：
- **`cfg_codec!`**  
  需要启用 `codec` 特征。用于与编解码（如 `tokio::codec`）相关的代码。
  ```rust
  #[cfg(feature = "codec")]
  #[cfg_attr(docsrs, doc(cfg(feature = "codec")))]
  ```

- **`cfg_net!`**  
  需要同时启用 `net` 和 `codec` 特征。用于网络相关的功能（如 TCP/UDP 支持）。
  ```rust
  #[cfg(all(feature = "net", feature = "codec"))]
  ```

- **`cfg_io!`**  
  需要启用 `io` 特征。用于基础 I/O 操作的模块。
  ```rust
  #[cfg(feature = "io")]
  ```

- **`cfg_io_util!`**  
  需要同时启用 `io` 和 `io-util` 特征。用于高级 I/O 工具（如流处理）。
  ```rust
  // 包裹在 cfg_io! 宏中，要求同时满足 "io" 和 "io-util"
  ```

- **其他宏**  
  包括 `cfg_compat!`（兼容性）、`cfg_rt!`（运行时）、`cfg_time!`（时间功能）等，均通过类似结构定义。

---

### **2. 宏的作用**
- **条件编译**：  
  通过 `#[cfg(...)]` 属性，确保代码仅在启用对应特征时编译。例如，若用户未启用 `codec` 特征，则 `cfg_codec!` 内的代码会被忽略。
  
- **文档标记**：  
  使用 `#[cfg_attr(docsrs, doc(cfg(...)))]`，在生成文档时标注功能所需的特征。例如，启用 `docsrs` 特征时，文档会显示某功能需要 `codec` 特征。

---

### **3. 嵌套宏示例**
```rust
cfg_io! {
    macro_rules! cfg_io_util { ... }
}
```
此处 `cfg_io_util!` 宏被包裹在 `cfg_io!` 中，表示其依赖 `io` 特征。只有当用户同时启用 `io` 和 `io-util` 特征时，`cfg_io_util!` 内的代码才会生效。

---

## **在项目中的角色**
此文件是 Tokio 库的**条件编译基础设施**，通过宏抽象化特征依赖的配置逻辑。它帮助开发者：
1. **模块化代码**：按功能划分模块，减少编译时的冗余。
2. **清晰文档**：自动标注功能依赖，方便用户理解如何启用特定功能。
3. **简化维护**：统一管理特征相关的条件编译逻辑，避免重复代码。
